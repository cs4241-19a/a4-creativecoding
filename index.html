<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Assignment 4</title>
  <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/three.min.js"></script>
  <script src="https://cdn.bootcss.com/jquery/1.8.1/jquery.js"></script>
  <script src="OrbitControls.js"></script>
  <script type="text/javascript" src="dat.gui.js"></script>
</head>
<body>
  
  		<div id="dropbox" >
			<input type="file" name="" value="" id="musicFile" >
        <span>Click to upload or simply drag the file here</span>
		</div>
  
  <span id="instruction">Instruction</span>
  <button id="hideBtn" onclick="hide()">HIHI</button>

</body>

<script type="text/javascript">
  
var AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;
var button = 1;
var audioContext = new AudioContext();
var dropbox, musicFile;

   var controls = new function(){
     this.scale = 1;
     this.color = 1;
 }
 
 var gui = new dat.GUI();
  gui.add(controls,'scale',0.5,3);
  gui.add(controls, 'color', { Red: 1, Green: 2, Blue: 3 } );

  
	dropbox = document.getElementById("dropbox");
	dropbox.addEventListener("dragenter", dragenter, false);
	dropbox.addEventListener("dragover", dragover, false);
	dropbox.addEventListener("dragleave", dragleave, false);
	dropbox.addEventListener("drop", drop, false);

	musicFile = document.getElementById("musicFile");
 	musicFile.addEventListener("change", readFile, false)

	// 目标进入drop区域
	function dragenter(e) {
		e.stopPropagation();
		e.preventDefault();
		dropbox.style.background = '#666'
	}
	// 目标位于drop区域上方
	function dragover(e) {
		e.stopPropagation();
		e.preventDefault();
	}
	// 目标离开drop区域
	function dragleave(e) {
		e.stopPropagation();
		e.preventDefault();
		dropbox.style.background = '#fbfbfb';
	}
	// 目标在drop区域被释放/放置（松开鼠标）
	function drop(e) {
		e.stopPropagation();
		e.preventDefault();
		dropbox.style.background = '#fbfbfb';
		handleFiles(e.dataTransfer.files[0]);
	}
	// 点击上传文件后的方法
	function readFile() {
		handleFiles($('#musicFile')[0].files[0]);
	}

	function handleFiles(f) {
  var file = f;//通过input上传的音频文件

  var fileReader = new FileReader();//使用FileReader异步读取文件
  fileReader.readAsArrayBuffer(file);//开始读取音频文件
  fileReader.onload = function(e) {//读取文件完成的回调
    //e.target.result 即为读取的音频文件（此文件为二进制文件）
    //下面开始解码操作 解码需要一定时间，这个时间应该让用户感知到
    var count = 0;

    var timer = setInterval(function(){
      count++;
    },1000)
    //开始解码，解码成功后执行回调函数 
    
    
    
    audioContext.decodeAudioData(e.target.result, function(buffer) {
      clearInterval(timer)

      // 创建AudioBufferSourceNode 用于播放解码出来的buffer的节点
      let audioBufferSourceNode = audioContext.createBufferSource();
      // 创建AnalyserNode 用于分析音频频谱的节点
      const analyser = audioContext.createAnalyser();
      //fftSize (Fast Fourier Transform) 是快速傅里叶变换，一般情况下是固定值2048。具体作用是什么我也不太清除，但是经过研究，这个值可以决定音频频谱的密集程度。值大了，频谱就松散，值小就密集。
      analyser.fftSize = 256 ;

      audioBufferSourceNode.connect(analyser);
      analyser.connect(audioContext.destination);
      console.log(audioContext.destination) 
      // 播放音频
      audioBufferSourceNode.buffer = buffer; //回调函数传入的参数 
      audioBufferSourceNode.start(); //部分浏览器是noteOn()函数，用法相同

      var dataArray = new Uint8Array(analyser.frequencyBinCount);
      console.log(dataArray)
      //alert(bufferLength);
      const step = Math.round(dataArray.length / appdata.length);
      function render() { 
          requestAnimationFrame(render);
         analyser.getByteFrequencyData(dataArray);

for(let j=0; j<appdata.length;j++){
     var value = dataArray[j * step]*controls.scale/5;
            if(value <1)
              value = 1;
            if(controls.color == 1){ 
	    		   let r = 176-j*5; 
	    		   let g = 50;
	    		   let b = 50;
	    		   let rgb = '#'+rgbToHex(r)+rgbToHex(g)+rgbToHex(b);
              appdata[j].material.color.set(rgb);
            } else if(controls.color == 2){
	    		   let g = 176-j*5; 
	    		   let r = 50;
	    		   let b = 50;
	    		   let rgb = '#'+rgbToHex(r)+rgbToHex(g)+rgbToHex(b);
              appdata[j].material.color.set(rgb);
            } else{
	    		   let b = 176-j*5; 
	    		   let g = 50;
	    		   let r = 50;
	    		   let rgb = '#'+rgbToHex(r)+rgbToHex(g)+rgbToHex(b);
              appdata[j].material.color.set(rgb);
            }
            
            appdata[j].scale.y = value;

  
  }
        renderer.render(scene, camera);
        }

      render();   
      
    });
    
    
  }
alert( 'Uploaded  (＾▽＾) ')
  } 
  
  var rgbToHex = function (rgb) { 
  var hex = Number(rgb).toString(16);
  if (hex.length < 2) {
       hex = "0" + hex;
  }
  return hex;
};
  
  
  const appdata = []
      
      
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);


      function add(number){
         for (let i = 0; i < number; i++) {
           let r = 256-80-i*5;
	    		  let g = 50;
			      let b = 50;
			      let rgb = '#'+r.toString(16)+g.toString(16)+b.toString(16);
            let geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            let material = new THREE.MeshBasicMaterial({color: rgb});
            let cube = new THREE.Mesh(geometry, material); 
            cube.position.set(i - number/2, 0, 0);
            scene.add(cube);
            appdata.push(cube);
            
           
    }
        }
      add(30);
        camera.position.z = 50;
         
  
  function hide(){

   if(button === 1){
      document.getElementById("instruction").style.display="none";
     alert(document.getElemnetById("hideBtn").innerHTML );
      document.getElemnetById("hideBtn").innerHTML = "Show";
     button=0;
    } else{
      document.getElementById("instruction").style.display="inline-block";
      //document.getElemnetById("hide").innerHTML ="Hide";
      button=1;
    }
  }

  
  

  

</script>
</html>